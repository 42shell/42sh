###########################################################################################
# simple bg jobs
###########################################################################################

true &
ps --ppid $$ -o state,comm

sleep 100 &
ps --ppid $$ -o state,comm
kill -9 $! 2>&/dev/null

cat &
ps --ppid $$ -o state,comm
kill -9 $! 2>&/dev/null

###########################################################################################
# pipelines
###########################################################################################

true | cat -e &
ps --ppid $$ -o state,comm

sleep 50 | sleep 50 &
ps --ppid $$ -o state,comm
pkill -9 -g $! 2>&/dev/null

cat | sleep 100 &
ps --ppid $$ -o state,comm
pkill -9 -g $! 2>&/dev/null

###########################################################################################
# subshells & processes
###########################################################################################

cat && sleep 100 &
# assert there are a subshell and a cat process
ps --ppid $$,$! -o state,comm
# kill the cat process
pkill -9 -P $! cat 2>&/dev/null
# assert subshell still there and there is no sleep process
ps --ppid $$,$! -o state,comm
# send -CONT to the subshell to terminate it
kill -CONT $! 2>&/dev/null
# assert subshell and cat processes have disappeared
ps --ppid $$,$! -o state,comm


# almost the same than previous one  
{ cat | sleep 100; } &
# assert all processes are there, sleep may be running or stopped sdepending on timing //fix this
ps --ppid $$,$! -o state,comm
# kill the cat process
pkill -9 -g $! cat 2>&/dev/null
# assert sleep process still there
ps --ppid $! -o state,comm
# kill the sleep process
pkill -9 -g $! sleep 2>&/dev/null
# send -CONT to the subshell to terminate it
kill -CONT $! 2>&/dev/null
# assert subshell and cat/sleep processes have disappeared
ps --ppid $$,$! -o state,comm

###########################################################################################
###########################################################################################
###########################################################################################

###########################################################################################
# async in subshells
###########################################################################################

# subshell in fg forks cat in async with stdin=/dev/null, cat exit immediately
(cat &)
jobs

# same but subshell is launched asynchronously 
(cat &) &
jobs

# assert ok is echoed
(cat & /bin/echo ok &)
jobs

# subshell in subshell
# the subshell forks another subshell in async to run the &&, and exits. The child subshell
# shall wait for the command to finish. This is not optimized, one subshell would be enough
(true && sleep 100 &)
# assert there are a subshell and a sleep process
ps -alx | egrep ./42sh$ | grep -v 'grep' | grep -v 'script' | awk -F' ' '{ print $13 }'
ps -alx | grep sleep | grep -v 'grep' | awk -F' ' '{ print $13 }'
# kill the sleep process
pkill -9 sleep 2>&/dev/null
# assert all processes have finished
ps -alx | egrep ./42sh$ | grep -v 'grep' | grep -v 'script' | awk -F' ' '{ print $13 }'
ps -alx | grep sleep | grep -v 'grep' | awk -F' ' '{ print $13 }'

###########################################################################################
# fg/bg jobspec
###########################################################################################

# ^Z fg
sleep 100
^Z
jobs
fg
^C

# ^Z bg
sleep 100
^Z
jobs
bg
jobs
fg
^C

# testing %n
sleep 100 & sleep 200 &
fg %3
fg %2
^C
fg %2
fg %0
fg %256
fg %1
^C

# testing %+ %% %
sleep 100 & sleep 200 & sleep 300 &
fg %+
^C
fg %%
^C
fg %
^C

# testing %-
sleep 100 & sleep 200 & sleep 300 &
fg %-
^C
fg %-
^C
fg %-
^C

# no current
fg
fg %
bg
bg %%

# job already done
true &
fg
true &
bg

###########################################################################################
# jobs jobspec
###########################################################################################

# -n
cat & PID=$!
jobs -n
kill -9 $PID 2>&/dev/null && sleep .2

# -p
cat & PID=$!
jobs -p
kill -9 $PID 2>&/dev/null && sleep .2

# -r -s
cat & P1=$!; sleep 1000 & P2=$!
jobs -s
jobs -r
kill -9 $P1 $P2 2>&/dev/null && sleep .2

sleep 1000& P1=$!; sleep 2000& P2=$!; sleep 3000& P3=$!; sleep 4000& P4=$! && sleep .2

# %n %+/-
jobs %0 %1
jobs %2
jobs %3
jobs %4
jobs %5
jobs %+
jobs %%
jobs %
jobs %-
jobs %*
jobs %error

# previously stopped job state is properly updated when SIGCONT
kill -TSTP $P2 2>&/dev/null && sleep .2
jobs
kill -CONT $P2 2>&/dev/null && sleep .2
jobs

# when highest id job is removed, highest id decreases
kill -9 $P4 2>&/dev/null && sleep .2
sleep 5000 & P5=$!
jobs

# when middle id job is removed, highest id dont change
kill -9 $P2 2>&/dev/null && sleep .2
sleep 6000 & P6=$!
jobs

# when all jobs are removed, id is back to 1
kill -9 $P1 $P3 $P5 $P6 2>&/dev/null && sleep .2
jobs
sleep 7000 & P7=$!
jobs
kill -9 $P7 2>&/dev/null

# jobs -l

cat | sleep 100 &
jobs -l
pkill -CONT -g $! sleep 2>&/dev/null
jobs -l
pkill -9 sleep 2>&/dev/null  //////
jobs -l
pkill -9 cat 2>&/dev/null ///////
jobs
