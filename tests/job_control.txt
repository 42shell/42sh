###########################################################################################
# simple bg jobs
###########################################################################################

/bin/echo ok &
jobs

sleep 100 & PID=$!
jobs
kill -9 $PID 2>&/dev/null
jobs

cat & PID=$!
jobs
kill -9 $PID 2>&/dev/null
jobs

###########################################################################################
# pipelines & jobs -l
###########################################################################################

/bin/echo abc | cat -e &
jobs -l

sleep 50 | sleep 50 &
jobs -l
pkill -9 sleep 2>&/dev/null
jobs

cat | sleep 100 &
jobs -l
pkill -9 cat 2>&/dev/null
jobs -l
pkill -9 sleep 2>&/dev/null
jobs

cat | sleep 100 &
jobs -l
pkill -CONT sleep 2>&/dev/null
jobs -l
pkill -9 sleep 2>&/dev/null
jobs -l
pkill -9 cat 2>&/dev/null
jobs

###########################################################################################
# subshells & processes
###########################################################################################

cat && sleep 100 &
# assert there are a subshell and a cat process
ps -alx | egrep ./42sh$ | grep -v 'grep' | grep -v 'script' | awk -F' ' '{ print $13 }'
ps -alx | egrep cat$ | grep -v 'grep' | awk -F' ' '{ print $13 }'
# kill the cat process
pkill -9 cat 2>&/dev/null
# assert subshell still there and there is no sleep process
ps -alx | egrep ./42sh$ | grep -v 'grep' | grep -v 'script' | awk -F' ' '{ print $13 }'
ps -alx | grep sleep | grep -v 'grep' | awk -F' ' '{ print $13 }'
# send -CONT to the subshell to terminate it
pkill -CONT 42sh 2>&/dev/null
# assert subshell and cat processes have disappeared
ps -alx | egrep ./42sh$ | grep -v 'grep' | grep -v 'script' | awk -F' ' '{ print $13 }'
ps -alx | egrep cat$ | grep -v 'grep' | awk -F' ' '{ print $13 }'

# almost the same than previous one  
{ cat | sleep 100; } &
# assert all processes are there, sleep may be running or stopped sdepending on pipeline
# timing
ps -alx | egrep ./42sh$ | grep -v 'grep' | grep -v 'script' | awk -F' ' '{ print $13 }'
ps -alx | egrep cat$ | grep -v 'grep' | awk -F' ' '{ print $13 }'
ps -alx | grep sleep | grep -v 'grep' | awk -F' ' '{ print $13 }'
# kill the cat process
pkill -9 cat 2>&/dev/null
# assert there is no sleep process
ps -alx | grep sleep | grep -v 'grep' | awk -F' ' '{ print $13 }'
# kill the sleep process
pkill -9 sleep 2>&/dev/null
# send -CONT to the subshell to terminate it
pkill -CONT 42sh 2>&/dev/null
# assert subshell and cat/sleep processes have disappeared
ps -alx | egrep ./42sh$ | grep -v 'grep' | grep -v 'script' | awk -F' ' '{ print $13 }'
ps -alx | egrep cat$ | grep -v 'grep' | awk -F' ' '{ print $13 }'
ps -alx | grep sleep | grep -v 'grep' | awk -F' ' '{ print $13 }'

###########################################################################################
# async in subshells
###########################################################################################

# subshell in fg forks cat in async with stdin=/dev/null, cat exit immediately
(cat &)
jobs

# same but subshell is launched asynchronously 
(cat &) &
jobs

# assert ok is echoed
(cat & /bin/echo ok &)
jobs

# subshell in subshell
# the subshell forks another subshell in async to run the &&, and exits. The child subshell
# shall wait for the command to finish. This is not optimized, one subshell would be enough
(true && sleep 100 &)
# assert there are a subshell and a sleep process
ps -alx | egrep ./42sh$ | grep -v 'grep' | grep -v 'script' | awk -F' ' '{ print $13 }'
ps -alx | grep sleep | grep -v 'grep' | awk -F' ' '{ print $13 }'
# kill the sleep process
pkill -9 sleep 2>&/dev/null
# assert all processes have finished
ps -alx | egrep ./42sh$ | grep -v 'grep' | grep -v 'script' | awk -F' ' '{ print $13 }'
ps -alx | grep sleep | grep -v 'grep' | awk -F' ' '{ print $13 }'

###########################################################################################
# fg/bg
###########################################################################################

# ^Z bg
sleep 100 &
fg
^Z
jobs
bg
jobs
fg
^C

# testing %n
sleep 100 & sleep 200 &
fg %2
^C
fg %2
bg %2
fg %1
^C

# testing %+/-
sleep 100 & sleep 200 & sleep 300 &
jobs
fg %+
^C
jobs
fg %-
^C
fg %-
^C

# no current
fg
bg

# job done
true &
fg
true &
bg

###########################################################################################
# jobs
###########################################################################################

# -n
cat & PID=$!
jobs -n
kill -9 $PID 2>&/dev/null

# -p
cat & PID=$!
jobs -p
kill -9 $PID 2>&/dev/null

# -r -s
cat & P1=$!; sleep 1000 & P2=$!
jobs -r
jobs -s
kill -9 $P1 $P2 2>&/dev/null

sleep 1000 & P1=$!; sleep 2000 & P2=$!; sleep 3000 & P3=$!; sleep 4000 & P4=$!

# %n %+/-
jobs %0
jobs %1
jobs %2
jobs %3
jobs %4
jobs %5
jobs %+
jobs %-
jobs %*
jobs %error

# stopped job bubbles up and previous '+' becomes '-',
# previously stopped job state is properly updated when SIGCONT
kill -TSTP $P2 2>&/dev/null
jobs
kill -TSTP $P3 2>&/dev/null
jobs
kill -CONT $P2 2>&/dev/null
jobs
kill -TSTP $P2 2>&/dev/null
jobs

# when highest id job is removed, highest id decreases
kill -9 $P4 2>&/dev/null
sleep 5000 & P5=$!
jobs

# when middle id job is removed, highest id dont change
kill -9 $P2 2>&/dev/null
sleep 6000 & P6=$!
jobs

# when all jobs are removed, id is back to 1
kill -9 $P1 $P3 $P5 $P6 2>&/dev/null
jobs
sleep 7000 & P7=$!
jobs
kill -9 $P7 2>&/dev/null
